{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenue sur le projet 1 de NSI de terminale","text":"<p>Projet de:  - Yanis Nogara  - Maxime Geoffroy</p>"},{"location":"#ceci-sert-de-documentation","title":"Ceci sert de documentation","text":"<p>Le code entier est disponible a l'adresse github laratatouille</p> <p>Le projet est en trois parties qui forment les trois onglets de cette page.</p>"},{"location":"#la-partie-turtle","title":"La partie turtle","text":"<p>La documentation de la partie turtle est disponible dans l'onglet turtle. Le code est disponible en t\u00e9l\u00e9chargement sur mon github Le code turtle</p>"},{"location":"image_ascii/","title":"Image Ascii","text":""},{"location":"image_ascii/#1-importation-de-la-bibliotheque-pillow","title":"1) Importation de la biblioth\u00e8que pillow","text":"<pre><code>import PIL.Image\n</code></pre> <p>On importe la librairie PIL (Pillow) qui permet de manipuler des images (ouvrir, redimensionner, convertir, etc.).</p>"},{"location":"image_ascii/#2-demande-de-chemin-de-limage","title":"2) Demande de chemin de l'image","text":"<pre><code>path = input(\"Enter the path to the image field : \\n\")\n</code></pre> <p>Le programme demande \u00e0 l\u2019utilisateur de saisir le chemin du fichier image (exemple : \"image.png\").</p>"},{"location":"image_ascii/#3-ouverture-de-limage","title":"3) Ouverture de l'image","text":"<pre><code>try:\n    img = PIL.Image.open(path)\n    img_flag = True\nexcept:\n    print(path, \"Unable to find image \");\n</code></pre> <p>On tente d\u2019ouvrir l\u2019image.</p> <p>Si le chemin est valide \u2192 img contient l\u2019image.</p> <p>Sinon un message d\u2019erreur s\u2019affiche: \"Unable to find image \".</p>"},{"location":"image_ascii/#4-recuperation-de-la-taille-de-limage-et-redimensionnement","title":"4) R\u00e9cuperation de la taille de l'image et redimensionnement","text":"<pre><code>width, height = img.size\naspect_ratio = height / width\nnew_width = 120\nnew_height = aspect_ratio * new_width * 0.55\nimg = img.resize((new_width, int(new_height)))\n</code></pre> <p>On adapte la taille pour que l\u2019image ASCII soit lisible :</p> <p>\"aspect_ratio\" garde les proportions de l\u2019image.</p> <p>\"new_width = 120\" fixe la largeur \u00e0 120 caract\u00e8res.</p> <p>\"new_height\" est calcul\u00e9e pour respecter les proportions de la page.</p> <p>\"img.resize(...)\u00e9 redimensionne l\u2019image.</p>"},{"location":"image_ascii/#5-conversion-en-gris","title":"5) Conversion en gris","text":"<pre><code>img = img.convert('L')\n</code></pre> <p>On convertit l\u2019image en noir et blanc (luminance, valeurs de 0 \u00e0 255). Cela permet d\u2019associer chaque pixel \u00e0 un caract\u00e8re ASCII selon sa luminosit\u00e9.</p>"},{"location":"image_ascii/#6-definition-des-caracteres-ascii","title":"6) D\u00e9finition des caract\u00e8res ASCII","text":"<pre><code>chars = [\"@\", \"J\", \"D\", \"%\", \"*\", \"P\", \"+\", \"Y\", \"$\", \",\", \".\"]\n</code></pre> <p>Cette liste contient les symboles utilis\u00e9s pour repr\u00e9senter les pixels.</p> <p>\"@\"  repr\u00e9sente un pixel tr\u00e8s sombre.</p> <p>\".\"  repr\u00e9sente un pixel clair. Ainsi, plus le pixel est sombre plus le caract\u00e8re choisi est dense.</p>"},{"location":"image_ascii/#7-conversion-des-pixels-en-caracteres","title":"7) Conversion des pixels en caract\u00e8res","text":"<p><pre><code>pixels = img.getdata()\nnew_pixels = [chars[pixel // 25] for pixel in pixels]\nnew_pixels = ''.join(new_pixels)\n</code></pre>  \u00c9tapes :</p> <p>img.getdata() r\u00e9cup\u00e8re la valeur de luminosit\u00e9 de chaque pixel.</p> <p>pixel // 25 ram\u00e8ne cette valeur entre 0 et 10 (car 255 \u00f7 25 \u2248 10).</p> <p>Chaque pixel est transform\u00e9 en un caract\u00e8re de la liste chars.</p> <p>Tous les caract\u00e8res sont assembl\u00e9s en une seule grande cha\u00eene \"(join)\".</p>"},{"location":"image_ascii/#8-decoupage-ligne-par-ligne","title":"8) D\u00e9coupage ligne par ligne","text":"<pre><code>new_pixels_count = len(new_pixels)\nascii_image = [new_pixels[index:index + new_width] for index in range(0, new_pixels_count, new_width)]\nascii_image = \"\\n\".join(ascii_image)\n</code></pre> <p>On remet en forme :</p> <p>On d\u00e9coupe la cha\u00eene de caract\u00e8res en lignes de largeur \"new_width (120)\".</p> <p>On assemble les lignes avec des sauts de ligne \"\\n\".</p>"},{"location":"image_ascii/#9-sauvegarde-dans-un-fichier-texte","title":"9) Sauvegarde dans un fichier texte","text":"<pre><code>with open(\"ascii_image.txt\", \"w\") as f:\n    f.write(ascii_image)\n</code></pre> <p>L\u2019image ASCII est enregistr\u00e9e dans un fichier texte \"ascii_image.txt\". Ainsi, l\u2019utilisateur peut l\u2019ouvrir et voir l\u2019image transform\u00e9 avec des caract\u00e8res.</p>"},{"location":"ascii/ascii/","title":"Ascii","text":""},{"location":"ascii/ascii/#carre","title":"Carr\u00e9","text":""},{"location":"ascii/ascii/#triangle","title":"Triangle","text":""},{"location":"ascii/ascii/#sapin","title":"Sapin","text":"<pre><code>def sapin(taille):\n# \u00c9tape 1 : triangle + tronc\n    print(\"sapin 1 :\")\n    print(\" \" * taille + \"^\")  \n    for i in range(1, taille + 1):\n        print(\" \" * (taille - i) + \"/\" + \" \" * (2 * i - 1) + \"\\\\\")\n    for k in range(3):  \n        print(\" \" * (taille - 1) + \"|||\")\n\n\n# \u00c9tape 2 : \u00e9toile\n    print(\"\\nsapin 2 :\")\n    print(\" \" * taille + \"*\")   \n    print(\" \" * taille + \"^\")   \n    for i in range(1, taille + 1):\n        print(\" \" * (taille - i) + \"/\" + \" \" * (2 * i - 1) + \"\\\\\")\n    for k in range(3):\n        print(\" \" * (taille - 1) + \"|||\")\n\n\n# \u00c9tape 3 : texture ' et \"\n    print(\"\\nsapin 3 :\")\n    print(\" \" * taille + \"*\")\n    print(\" \" * taille + \"^\")\n    for i in range(1, taille + 1):\n        ligne = \"\"\n        for j in range(2 * i - 1):\n            if j % 2 == 0:\n                ligne += \"'\"\n            else:\n                ligne += '\"'\n        print(\" \" * (taille - i) + \"/\" + ligne + \"\\\\\")\n    for k in range(3):\n        print(\" \" * (taille - 1) + \"|||\")\n\n\n# \u00c9tape 4 : d\u00e9corations al\u00e9atoires\n    print(\"\\nsapin4! :\")\n    print(\" \" * taille + \"*\")\n    print(\" \" * taille + \"^\")\n    for i in range(1, taille + 1):\n        ligne = \"\"\n        for j in range(2 * i - 1):\n            if random.random() &lt; 0.2:   # 20% chance d'avoir une boule\n                ligne += \"o\"\n            else:\n                ligne += random.choice([\"'\", '\"'])\n        print(\" \" * (taille - i) + \"/\" + ligne + \"\\\\\")\n    for k in range(3):\n        print(\" \" * (taille - 1) + \"|||\")\n\n\n\nsapin(6)\n</code></pre>"},{"location":"ascii/ascii/#projet","title":"Projet","text":""},{"location":"ascii/carre/","title":"Carr\u00e9","text":""},{"location":"ascii/carre/#1creation-dun-carre","title":"1)Cr\u00e9ation d'un carr\u00e9","text":"<p>On commence par tracer un carr\u00e9 :</p> <p>La premi\u00e8re et la derni\u00e8re ligne sont enti\u00e8rement remplies de <code>X</code>.</p> <p>Les lignes du milieu ne gardent que les bords, ce qui forme un carr\u00e9 creux. <pre><code>def carre(cote):\n    # Premi\u00e8re ligne du carr\u00e9\n    print(\"X \" * cote)\n\n    # les lignes du milieux\n    for i in range(cote - 2):\n        print(\"X \" + \"  \" * (cote - 2) + \"X \")\n\n    # Derni\u00e8re ligne du carr\u00e9\n    if cote &gt; 1:  # pour \u00e9viter un double affichage du carr\u00e9 quand le cote est egale a 1\n        print(\"X \" * cote)\n\n# permet de choisir n'importe quel nombre de \"X\" pour le carr\u00e9\nn = int(input(\"Longueur du c\u00f4t\u00e9 : \"))\ncarre(n)\n</code></pre></p>"},{"location":"ascii/carre/#2carre-avec-une-diagonale-au-milieu","title":"2)Carr\u00e9 avec une diagonale au milieu","text":"<p>On reprend le carr\u00e9 vide et on ajoute la diagonale principale du haut a gauche jusqu'en bas a droite. Cela dessine une ligne traversant le carr\u00e9 en plus de son contour.ce qui va form\u00e9 un carr\u00e9 avec une diagonale au milieu. <pre><code>def carre_diagonale(n):\n    for i in range(n):\n        ligne = \"\"\n        for j in range(n):\n            if i == 0 or i == n-1 or j == 0 or j == n-1 or i == j :\n                ligne += \"X \"\n            else:\n                ligne += \"  \"\n        print(ligne)\n\ncarre_diagonale(7)\n</code></pre></p>"},{"location":"ascii/carre/#3carre-ave-une-croix","title":"3)Carr\u00e9 ave une croix","text":"<p>Ici, le carr\u00e9 est compl\u00e9t\u00e9 par deux axes centraux :</p> <p>Une ligne horizontale au milieu. Une ligne verticale au milieu. On obtient un carr\u00e9 en forme de croix. <pre><code>def carre_croix(cote):\n    for i in range(cote):\n        ligne = \"\"\n        for j in range(cote):\n            # Bordures\n            if i == 0 or i == cote - 1 or j == 0 or j == cote - 1:\n                ligne += \"X \"\n            # Ligne centrale horizontale\n            elif i == cote // 2:\n                ligne += \"X \"\n            # Ligne centrale verticale\n            elif j == cote // 2:\n                ligne += \"X \"\n            # les espaces\n            else:\n                ligne += \"  \"\n        print(ligne)\n\n\n# Exemple d'utilisation de notre fonction\nn = int(input(\"Longueur du c\u00f4t\u00e9 : \"))\ncarre_croix(n)\n</code></pre></p>"},{"location":"ascii/carre/#4carre-origami","title":"4)carr\u00e9 origami","text":"<p>Enfin pour ce carr\u00e9,on va ajouter deux diagonales  :</p> <ul> <li> <p>Une diagonale descendante et compl\u00e8te.</p> </li> <li> <p>Et une diagonale montante qui s\u2019arr\u00eate au centre. Le tout donne un effet \u201corigami\u201d \u00e0 l\u2019int\u00e9rieur du carr\u00e9. <pre><code>def origami(cote):\n    for i in range(cote):\n        ligne = \"\"\n        for j in range(cote):\n            if i == 0 or i == cote - 1 or j == 0 or j == cote - 1:  # bordures\n                ligne += \"X \"\n            elif i == j:  # diagonale descendante compl\u00e8te\n                ligne += \"X \" \n            elif i + j == cote - 1 and i &lt;= cote // 2:  # diagonale montante arr\u00eat\u00e9e au milieu\n                ligne += \"X \"\n            else:\n                ligne += \"  \"\n        print(ligne)\n\n\n# Exemple\nn = int(input(\"Longueur du c\u00f4t\u00e9 : \"))\norigami(n)\n</code></pre></p> </li> </ul>"},{"location":"ascii/sapin/","title":"Sapin","text":""},{"location":"ascii/sapin/#1-creation-du-sapin","title":"1) Cr\u00e9ation du sapin","text":"<p>Dans cette premi\u00e8re \u00e9tape, on trace la structure du sapin : on cr\u00e9e le sapin vide</p> <p>Un petit chapeau <code>^</code> au sommet.</p> <p>Des branches vides avec<code>/ et \\</code>.</p> <p>Un tronc repr\u00e9sent\u00e9 par trois fois<code>|||</code>.</p> <p>C\u2019est la base de notre sapin de No\u00ebl. <pre><code>def sapin(taille):\n# \u00c9tape 1 : triangle + tronc\n    print(\"sapin 1 :\")\n    print(\" \" * taille + \"^\")  \n    for i in range(1, taille + 1):\n        print(\" \" * (taille - i) + \"/\" + \" \" * (2 * i - 1) + \"\\\\\")\n    for k in range(3):  \n        print(\" \" * (taille - 1) + \"|||\")\n</code></pre></p>"},{"location":"ascii/sapin/#2etoile-sur-le-sapin-vide","title":"2)Etoile sur le sapin vide","text":"<p>On ajoute une \u00e9toile <code>*</code> au sommet du sapin. Elle vient se placer juste au-dessus du <code>^</code> et rend le sapin plus festif et plus sublime.</p> <pre><code># \u00c9tape 2 : \u00e9toile\n    print(\"\\nsapin 2 :\")\n    print(\" \" * taille + \"*\")   \n    print(\" \" * taille + \"^\")   \n    for i in range(1, taille + 1):\n        print(\" \" * (taille - i) + \"/\" + \" \" * (2 * i - 1) + \"\\\\\")\n    for k in range(3):\n        print(\" \" * (taille - 1) + \"|||\")\n</code></pre>"},{"location":"ascii/sapin/#3-ajout-des-decoration","title":"3) ajout des decoration","text":"<p>Pour donner du style, on remplit les branches avec une alternance de guillemets<code>' et \"</code>. Cela cr\u00e9e un motif r\u00e9gulier \u00e0 l\u2019int\u00e9rieur du sapin et simule des d\u00e9corations accroch\u00e9es aux branches comme des guirlandes. <pre><code># \u00c9tape 3 : texture ' et \"\n    print(\"\\nsapin 3 :\")\n    print(\" \" * taille + \"*\")\n    print(\" \" * taille + \"^\")\n    for i in range(1, taille + 1):\n        ligne = \"\"\n        for j in range(2 * i - 1):\n            if j % 2 == 0:\n                ligne += \"'\"\n            else:\n                ligne += '\"'\n        print(\" \" * (taille - i) + \"/\" + ligne + \"\\\\\")\n    for k in range(3):\n        print(\" \" * (taille - 1) + \"|||\")\n</code></pre></p>"},{"location":"ascii/sapin/#4ajout-des-boules-et-decorations-aleatoires-dans-le-sapin","title":"4)Ajout des boules et d\u00e9corations al\u00e9atoires dans le sapin","text":"<p>On ajoute plein de d\u00e9corations en rendant le sapin al\u00e9atoire :</p> <p>Chaque emplacement a 20 % de chance de contenir une boule<code>o</code>.</p> <p>Sinon, il contient un guillemet <code>' ou \"</code>.</p> <p>Ainsi, chaque ex\u00e9cution du programme g\u00e9n\u00e8re un sapin diff\u00e9rent, unique et d\u00e9cor\u00e9 de fa\u00e7on al\u00e9atoire se qui rend le tout magique comme la magie de noel. <pre><code># \u00c9tape 4 : boule et d\u00e9co al\u00e9atoires\n    print(\"\\nsapin4! :\")\n    print(\" \" * taille + \"*\")\n    print(\" \" * taille + \"^\")\n    for i in range(1, taille + 1):\n        ligne = \"\"\n        for j in range(2 * i - 1):\n            if random.random() &lt; 0.2:   # 20% chance d'avoir une boule\n                ligne += \"o\"\n            else:\n                ligne += random.choice([\"'\", '\"'])\n        print(\" \" * (taille - i) + \"/\" + ligne + \"\\\\\")\n    for k in range(3):\n        print(\" \" * (taille - 1) + \"|||\")\n\n\n\nsapin(6)\n</code></pre></p>"},{"location":"ascii/triangle/","title":"Triangle","text":""},{"location":"ascii/triangle/#1fonction-triangle","title":"1)Fonction triangle","text":"<p>Ce programme nous permet de creer un triangle sous forme de fonction, l'utilisateur peut modifier a  n'importe quel moment le code en modifiant la valeur 6 dans la derni\u00e8re ligne du programme <pre><code>def triangle(n):\n    for i in range(1, n+1):\n        if i == 1:  # la premi\u00e8re ligne = 1 X\n            print(\" \" * (n-i) + \"X\")\n        elif i == n:  # la derni\u00e8re ligne = pleine\n            print(\"X\" * (2*i-1))\n        else:  # lignes interm\u00e9diaires = X ... X\n            print(\" \" * (n-i) + \"X\" + \" \" * (2*i-3) + \"X\")\n\n\ntriangle(9)\n</code></pre> <pre><code>\n</code></pre></p>"},{"location":"turtle/exterieur/","title":"le fichier exterieur.py","text":""},{"location":"turtle/exterieur/#le-fichier-en-petites-etapes","title":"le fichier en petites etapes","text":"<p>Le fichier exterieur.py est responsable de touts les dessins qui touchent les objets ext\u00e9rieurs aux batiments et qui ne bouge pas.</p>"},{"location":"turtle/exterieur/#1-la-fonction-dessin_base","title":"1) la fonction <code>dessin_base</code>","text":"<pre><code># les dessins de base\ndef dessin_base(x:int):\n    formes.rectangle(x-100, -100, x+20000, 250, \"#13721e\", True, \"#13721e\")\n    formes.rectangle(x-100, 35, x+20000, 100, \"#323232\", True, \"#323232\")\n    for i in range(1000):\n        formes.ligne(i*20, 85, i*20+10, 85, \"#adadad\")\n</code></pre> <p>Cette fonction prend en charge un argument: - <code>x</code> : la position x du debut ou l'on va cr\u00e9er le parterre et la route</p>"},{"location":"turtle/exterieur/#2-la-fonction-soleil_obj-et-la-fonction-fonction_soleil_lune","title":"2) la fonction <code>soleil_obj</code> et la fonction <code>fonction_soleil_lune</code>","text":"<pre><code># le soleil et la lune\ndef soleil_obj(i:int, soleil:Turtle, screen, type:str, temps:float) -&gt; None:\n    \"\"\" fait bouger le soleil et la lune \"\"\"\n    temps_reste = time.time() - temps\n    if temps_reste &lt;= 5:\n        # effacer l'ancien soleil\n        soleil.clear()\n        soleil_x = (i)*1400 + temps_reste*1400 / 5\n\n\n        # afficher le nouveau\n        if type == \"soleil\":\n            formes.cercle(soleil_x, fonction_soleil_lune(soleil_x), 25, \"#e2d257\", True, \"#ffe312\", soleil)\n        elif type == \"lune\":\n            formes.cercle(soleil_x, fonction_soleil_lune(soleil_x), 25, \"#555555\", True, \"#c1c1c1\", soleil)\n\n\n        screen.ontimer(lambda:soleil_obj(i, soleil, screen, type, temps), 20)\n\n\ndef fonction_soleil_lune(x:int) -&gt; int:\n    \"\"\" calcule l'arc de cercle du soleil \"\"\"\n    return 400 + abs(250 * math.sin(math.pi * x / 1400 ))\n</code></pre> <p>La premi\u00e8re fonction est r\u00e9cursive gr\u00e2ce a ontimer de screen Elle prend en charge des arguments: - <code>i</code> : le nombre de boucles d\u00e9j\u00e0 effectu\u00e9es qui permet de calculer le decalage pour les nombreuses fonctions - <code>soleil</code> : la turtle qui permet de dessiner le soleil et la lune - <code>screen</code> : screen pour permettre de ne pas relancer un grand nombre d'instances de cette classe qui permet de touches a des fonctions de l'ecran - <code>type</code> : une cha\u00eene de caract\u00e8res soit \"soleil\" soit \"lune\" - <code>temps</code> : la seconde a laquelle a debut\u00e9 la premi\u00e8re it\u00e9ration afin de calculer le decalage</p>"},{"location":"turtle/exterieur/#3-la-fonction-lampadaires-et-la-fonction-dessin_lampadaire","title":"3) la fonction <code>lampadaires</code> et la fonction <code>dessin_lampadaire</code>","text":"<pre><code># les lampadaires\ndef lampadaire(i:int) -&gt; None:\n    \"\"\" dessine les lampadaires \"\"\"\n    for k in range(6):\n        dessin_lampadaire(i*1400+100+k*240)\n\n\ndef dessin_lampadaire(x:int) -&gt; None:\n    \"\"\" dessine un lampadaire a x \"\"\"\n    formes.ligne(x, 230, x, 150, \"#606060\")\n    formes.triangle(x-3, 230, x+3, 230, x, 235, \"#606060\", True, \"#606060\")\n</code></pre> <p>Ces fonctions prennent en charge les argument: - <code>i</code> : le nombre de boucles d\u00e9j\u00e0 effectu\u00e9es qui permet de calculer le decalage pour les nombreuses fonctions Pour la premi\u00e8re et  - <code>x</code> : la position a laquelle dessiner le lampadaire Pour la deuxi\u00e8me</p> <p>Ces fonctions permettent de dessiner les lampadaires.</p>"},{"location":"turtle/formes/","title":"le fichier formes.py","text":""},{"location":"turtle/formes/#le-fichier-en-petites-etapes","title":"le fichier en petites etapes","text":""},{"location":"turtle/formes/#1-la-fonction-carre","title":"1) la fonction <code>carre</code>","text":"<p><pre><code>def carre(x:int, y:int, cote:int, color:str, fill:bool=False, fill_color:str=\"#ffffff\", turtle=turtle) -&gt; None:\n    \"\"\" dessine un carre \"\"\"\n    turtle.goto(x, y)\n    turtle.pencolor(color)\n    turtle.pendown()\n    if fill:\n        turtle.fillcolor(fill_color)\n        turtle.begin_fill()\n    turtle.setheading(0)\n    for _ in range(4):\n        turtle.forward(cote)\n        turtle.left(90)\n    if fill:\n        turtle.end_fill()\n    turtle.penup()\n    turtle.update()\n    return None\n</code></pre> Cette fonction prend en charge une grande liste d'arguments :   - <code>x</code> : la position \\(x\\) en haut a gauche du carr\u00e9  - <code>y</code> : la position \\(y\\) en haut a gauche du carr\u00e9  - <code>cote</code> : la longueur d'un cote (par defaut False)  - <code>color</code> : la couleur du carr\u00e9  - <code>fill</code> : un bool\u00e9en qui permet de savoir si on rempli ou pas le carr\u00e9  - <code>fill_color</code> : la couleur de remplissage (par defaut blandc)  - <code>turtle</code> : la turtle qui permet de dessiner le carr\u00e9 (par defaut la turtle de base)</p>"},{"location":"turtle/formes/#1-la-fonction-rectangle","title":"1) la fonction <code>rectangle</code>","text":"<pre><code>def rectangle(x:int, y:int, width:int, height:int, color:str, fill:bool=False, fill_color:str=\"#ffffff\", turtle=turtle) -&gt; None:\n    \"\"\" dessine un rectangle \"\"\"\n    turtle.goto(x, y)\n    turtle.pencolor(color)\n    turtle.pendown()\n    if fill:\n        turtle.fillcolor(fill_color)\n        turtle.begin_fill()\n    turtle.setheading(0)\n    for _ in range(2):\n        turtle.forward(width)\n        turtle.left(90)\n        turtle.forward(height)\n        turtle.left(90)\n    if fill:\n        turtle.end_fill()\n    turtle.penup()\n    turtle.update()\n    return None\n</code></pre> <p>Cette fonction prend en charge une grande liste d'arguments :   - <code>x</code> : la position \\(x\\) en haut a gauche du rectangle  - <code>y</code> : la position \\(y\\) en haut a gauche du rectangle  - <code>width</code> : la largeur du recrangle   - <code>height</code> : la hauteur du rectangle   - <code>color</code> : la couleur du rectangle  - <code>fill</code> : un bool\u00e9en qui permet de savoir si on rempli ou pas le rectangle  - <code>fill_color</code> : la couleur de remplissage (par defaut blandc)  - <code>turtle</code> : la turtle qui permet de dessiner le rectangle (par defaut la turtle de base)</p>"},{"location":"turtle/formes/#1-la-fonction-cercle","title":"1) la fonction <code>cercle</code>","text":"<pre><code>def cercle(x:int, y:int, radius:int, color:str, fill:bool=False, fill_color:str=\"#ffffff\", turtlle=turtle) -&gt; None:\n    \"\"\" dessine un cercle \"\"\"\n    turtlle.setheading(90)\n    turtlle.goto(x - radius, y)\n    turtlle.pencolor(color)\n    turtlle.pendown()\n    if fill:\n        turtlle.fillcolor(fill_color)\n        turtlle.begin_fill()\n    turtlle.circle(radius)\n    if fill:\n        turtlle.end_fill()\n    turtlle.penup()\n    turtle.update()\n    return None\n</code></pre> <p>Cette fonction prend en charge une grande liste d'arguments :   - <code>x</code> : la position \\(x\\) a gauche du cercle  - <code>y</code> : la position \\(y\\) a gauche du cercle  - <code>radius</code> : le rayon du cercle  - <code>color</code> : la couleur du cercle  - <code>fill</code> : un bool\u00e9en qui permet de savoir si on rempli ou pas le cercle  - <code>fill_color</code> : la couleur de remplissage (par defaut blandc)  - <code>turtle</code> : la turtle qui permet de dessiner le cercle (par defaut la turtle de base)</p>"},{"location":"turtle/formes/#1-la-fonction-triangle","title":"1) la fonction <code>triangle</code>","text":"<pre><code>def triangle(x1:int, y1:int, x2:int, y2:int, x3:int, y3:int, color:str, fill:bool=False, fill_color:str=\"#ffffff\", turtle=turtle) -&gt; None:\n    \"\"\" dessine un triangle \"\"\"\n    turtle.goto(x1, y1)\n    turtle.pendown()\n    turtle.pencolor(color)\n    if fill:\n        turtle.fillcolor(fill_color)\n        turtle.begin_fill()\n    turtle.goto(x2, y2)\n    turtle.goto(x3, y3)\n    turtle.goto(x1, y1)\n    if fill:\n        turtle.end_fill()\n    turtle.penup()\n    turtle.update()\n    return None\n</code></pre> <p>Cette fonction prend en charge une grande liste d'arguments :   - <code>x1</code> : la position \\(x\\) du premier point  - <code>y1</code> : la position \\(y\\) du premier point  - <code>x2</code> : la position \\(x\\) du deuxi\u00e8me point  - <code>y2</code> : la position \\(y\\) du deuxi\u00e8me point  - <code>x3</code> : la position \\(x\\) du troisi\u00e8me point  - <code>y3</code> : la position \\(y\\) du troisi\u00e8me point  - <code>color</code> : la couleur du triangle  - <code>fill</code> : un bool\u00e9en qui permet de savoir si on rempli ou pas le triangle  - <code>fill_color</code> : la couleur de remplissage (par defaut blandc)  - <code>turtle</code> : la turtle qui permet de dessiner le triangle (par defaut la turtle de base)</p>"},{"location":"turtle/formes/#1-la-fonction-ligne","title":"1) la fonction <code>ligne</code>","text":"<pre><code>def ligne(x1:int, y1:int, x2:int, y2:int, color:str, turtle=turtle) -&gt; None:\n    \"\"\" trace une ligne en x1, y1, x2, y2 \"\"\"\n    turtle.goto(x1, y1)\n    turtle.pendown()\n    turtle.pencolor(color)\n    turtle.goto(x2, y2)\n    turtle.penup()\n    return None\n</code></pre> <p>Cette fonction prend en charge une grande liste d'arguments :   - <code>x1</code> : la position \\(x\\) du premier point  - <code>y1</code> : la position \\(y\\) du premier point  - <code>x2</code> : la position \\(x\\) du deuxi\u00e8me point  - <code>y2</code> : la position \\(y\\) du deuxi\u00e8me point  - <code>color</code> : la couleur du triangle  - <code>turtle</code> : la turtle qui permet de dessiner le triangle (par defaut la turtle de base)</p>"},{"location":"turtle/formes/#1-la-fonction-trace_porte_arrondie","title":"1) la fonction <code>trace_porte_arrondie</code>","text":"<pre><code>def trace_porte_arrondie(x:int, y:int, color:str, fill_color:str, turtle=turtle):\n    turtle.goto(x, y+35)\n    turtle.pendown()\n    turtle.setheading(-90)\n    turtle.fillcolor(fill_color)\n    turtle.begin_fill()\n    turtle.circle(15)\n    turtle.end_fill()\n    turtle.penup()\n    turtle.goto(x, y)\n    turtle.pencolor(color)\n    turtle.pendown()\n    turtle.begin_fill()\n    turtle.setheading(0)\n    turtle.forward(30)\n    turtle.left(90)\n    turtle.forward(35)\n    turtle.left(90)\n    turtle.penup()\n    turtle.forward(30)\n    turtle.pendown()\n    turtle.left(90)\n    turtle.forward(35)\n    turtle.left(90)\n    turtle.end_fill()\n    turtle.penup()\n    turtle.update()\n    return None\n</code></pre> <p>Cette fonction prend en charge une grande liste d'arguments :   - <code>x</code> : la position \\(x\\) en bas a gauche de la porte  - <code>y</code> : la position \\(y\\) en bas a gauche de la porte  - <code>color</code> : la couleur de la porte  - <code>fill_color</code> : la couleur de remplissage (par defaut blandc)  - <code>turtle</code> : la turtle qui permet de dessiner la porte (par defaut la turtle de base)</p>"},{"location":"turtle/immeuble/","title":"le fichier immeubles.py","text":""},{"location":"turtle/immeuble/#le-fichier-en-petites-etapes","title":"le fichier en petites etapes","text":"<p>Ce fichier est la base de la cr\u00e9ation et du dessin des immeubles. Ce fichier etant complexe a comprendre il b\u00e9n\u00e9ficiera d'une attention particuli\u00e8re.</p> <p>Ce fichier poss\u00e8de plusieures fonctions.</p>"},{"location":"turtle/immeuble/#1-la-fonction-immeubles","title":"1) la fonction <code>immeubles</code>","text":"<p>Ce fichier est un peu la base de tout le fichier c'est lui qui va donner l'affichages aux etages de l'immeuble. <pre><code>def immeuble(x:int):\n    \"\"\" charge les variables de la fonction \"\"\"\n\n    couleur = \"#{:06x}\".format(random.randint(0, 0xFFFFFF))\n    nombre_etages = random.randint(1, 5)\n\n    for i in range(nombre_etages):\n        etage(x, i, couleur)\n    toit(x, nombre_etages)\n</code></pre> Cette fonction prend comme argument:  - <code>x</code> : la position \\(x\\) en haut a gauche de la fenetre</p> <p>D\u00e9cortiquons la fonction: <code>couleur = \"#{:06x}\".format(random.randint(0, 0xFFFFFF))</code> Cette ligne permet de generer al\u00e9atoirement une couleur qui sera compos\u00e9e de 6 chiffres h\u00e9xad\u00e9cimaux. Le .format permet de remplacer le :06x par les nombres al\u00e9atoires.</p> <p>on a \u00e9galement une boucle qui g\u00e9r\u00e8re le bon nombre d'\u00e9tages. la fonction fini par \u00e9x\u00e9cuter la fonction toit qui dessinera un toit al\u00e9atoire.</p>"},{"location":"turtle/immeuble/#2-la-fonction-etage","title":"2) la fonction <code>etage</code>","text":"<p>Cette fonction va generer et dessiner un etage avec les fenetres la porte et les balcons. <pre><code>def etage(x:int, numero_etage:int, couleur_etage:str):\n    \"\"\" dessine un etage \"\"\"\n    height = 60\n    width = 140\n    hauteur_rue = 150\n\n\n    formes.rectangle(x,\n                        numero_etage * height + hauteur_rue,\n                        width,\n                        height,\n                        \"#000000\",\n                        True,\n                        couleur_etage)\n    if numero_etage == 0:\n        position_porte = random.randint(0, 2)\n        for i in range(3):\n            if i == position_porte:\n                porte(x, numero_etage*height+hauteur_rue, i)\n                continue\n            fenetre(x, numero_etage*height+hauteur_rue, i)\n    else:\n        for i in range(3):\n            type_fenetre = random.randint(0, 1)\n            if type_fenetre == 0:\n                fenetre(x, numero_etage*height+hauteur_rue, i)\n            else:\n                balcon(x+15+i*40, numero_etage*height+hauteur_rue)\n</code></pre> Cette fonction prend en charge plusieurs arguments:  - <code>x</code> : la position \\(x\\) a gauche de l'\u00e9tage  - <code>numero_etage</code> : le nombre d'\u00e9tages d\u00e9j\u00e0 dessin\u00e9s  - <code>couleur_etage</code> : la couleur de l'\u00e9tage</p> <p>Cette fonction peut se diviser en 3 parties plus simples a comprendre. De la ligne 1 a la ligne 14 La fonction initialise les variables et dessines le sol vert. De la ligne 15 a la ligne 21 Si on est au premier \u00e9tage. Il genere la position de la porte. Et il dessiner 3 objets dont la porte et des fenetres normales. De la ligne 22 a la ligne 28 La fonction g\u00e9n\u00e8re 3 fenetres ou balcons al\u00e9atoirement.</p>"},{"location":"turtle/immeuble/#3-la-fonction-fenetre","title":"3) la fonction <code>fenetre</code>","text":"<p><pre><code>def fenetre(x:int, y:int, nombre_fenetre:int):\n    \"\"\" dessine la fenetre \"\"\"\n    taille = 30\n    decalage_mur = 15\n    decalage_objets = 10\n    decalage_hauteur = 20\n    couleur = \"#3799c3\"\n\n\n    decalage_x = decalage_mur + nombre_fenetre*(decalage_objets + taille)\n    formes.carre(x + decalage_x,\n                    y+decalage_hauteur,\n                    taille,\n                    \"#000000\",\n                    True,\n                    couleur)\n</code></pre> Cette fonction prend en charge plusieurs arguments:  - <code>x</code> : la position \\(x\\) a gauche de la fenetre  - <code>y</code> : la position \\(y\\) en haut de la fenetre  - <code>nombre_fenetre</code> : le nombre de fenetres d\u00e9j\u00e0 dessin\u00e9es</p> <p>Cette fonction peux aussi etre d\u00e9coup\u00e9e en parties simples. De la ligne 1 a la ligne 7 La fonction initialise les variables. De la ligne 10 a la ligne 16 La fonction calcule le decalage a avoir avec le cote gauche de l'immeuble. Puis elle dessine un carre qui est en fait la fentre de 30px de cote.</p>"},{"location":"turtle/immeuble/#4-la-fonction-creer_forme_balcon","title":"4) la fonction <code>creer_forme_balcon</code>","text":"<p>Cette fonction enregistre les paires de coordon\u00e9es des lignes du balcon. Cela va permettre de cr\u00e9er un 'tampon' avec la forme du balcon qui va pouvoir \u00eatre pos\u00e9.</p> <pre><code>def creer_forme_balcon():\n    \"\"\" cree une forme pour le balcon \"\"\"\n    balcon_shape = Shape(\"compound\")\n\n    # fen\u00eatre (rectangle rempli bleu)\n    fenetre = ((0,0), (23,0), (23,36), (0,36))\n    balcon_shape.addcomponent(fenetre, \"#3799c3\", \"black\")\n\n    # barre horizontale du balcon\n    barre = ((-3,22),(27,22))\n    balcon_shape.addcomponent(barre, \"black\", \"black\")\n\n    # barres verticales \n    for i in range(0,33,3):\n        barre_v = ((-3+i,22), (-3+i,0))\n        balcon_shape.addcomponent(barre_v, \"black\", \"black\")\n\n    # on enregistre la forme\n    register_shape(\"balcon\", balcon_shape)  \n</code></pre> <p>Cette fonction est d\u00e9j\u00e0 expliqu\u00e9e dans le code pour ma compr\u00e9hension personelle.</p>"},{"location":"turtle/immeuble/#5-la-fonction-balcon","title":"5) la fonction <code>balcon</code>","text":"<p>Met un 'tampon' du balcon sur la toile</p> <pre><code>def balcon(x:int, y:int):\n    \"\"\" dessine un balcon \"\"\"\n    setheading(90)\n    shape(\"balcon\")\n    goto(x, y)\n    stamp()\n</code></pre> <p>Cette fonction prend un chage les arguments:  - <code>x</code> : la position \\(x\\) du balcon  - <code>y</code> : la position \\(y\\) du balcon</p>"},{"location":"turtle/immeuble/#6-la-fonction-porte","title":"6) la fonction <code>porte</code>","text":"<pre><code>def porte(x:int, y:int, nombre_fenetre:int) -&gt; None:\n    \"\"\" dessine la porte \"\"\"\n    height = 50\n    width = 30\n    decalage_mur = 15\n    decalage_objets = 10\n    clanche_x1 = 23\n    clanche_x2 = 28\n    clanche_y = 20\n\n    couleur = \"#{:06x}\".format(random.randint(0, 0xFFFFFF))\n    type_porte = random.randint(0, 1)\n\n    if type_porte == 0:\n        formes.rectangle(x+decalage_mur+(nombre_fenetre*(width+decalage_objets)), y, width, height, \"#000000\", True, couleur)\n    elif type_porte == 1:\n        formes.trace_porte_arrondie(x+decalage_mur+(nombre_fenetre*(width+decalage_objets)), y, \"#000000\", couleur)\n\n    # clanche\n    formes.ligne(x+decalage_mur+(nombre_fenetre*(width+decalage_objets))+clanche_x1,\n                 y+clanche_y,\n                 x+decalage_mur+(nombre_fenetre*(width+decalage_objets))+clanche_x2,\n                 y+clanche_y,\n                 \"#000000\")\n</code></pre> <p>Cette fonction peux se d\u00e9couper en trois parties. De la ligne 1 a la ligne 12 La fonction initialise les variables de la fonction</p> <p>De la ligne 14 a la ligne 17 la fonction peux dessiner deux portes diff\u00e9rentres l'une rectangulaire, l'autre avec le dessus arrondi.</p> <p>De la ligne 19 a la ligne 24 La fonction dessine la clanche.</p>"},{"location":"turtle/lumieres/","title":"le fichier lumieres.py","text":""},{"location":"turtle/lumieres/#le-fichier-en-petites-etapes","title":"le fichier en petites etapes","text":"<p>Ce fichier poss\u00e8de plusieures fonctions</p>"},{"location":"turtle/lumieres/#1-la-fonction-couleur_ciel","title":"1) la fonction <code>couleur_ciel</code>","text":"<pre><code>def couleur_ciel(temps_depart:float, heure:str, screen):\n    \"\"\" change la couleur du ciel le matin ou le soir \"\"\"\n    temps = time.time() - temps_depart\n    if temps &lt;= 5:\n        ontimer(lambda:couleur_ciel(temps_depart, heure, screen), 50)\n    elif 5 &lt; temps &lt; 8:\n        couleur1 = (39, 245, 242)\n        couleur2 = (0, 0, 0)\n        etat_changement = (temps-5)/3\n        direction = (True if heure == \"jour\" else False)\n        couleur = _calcul_couleur(couleur1, couleur2, etat_changement, direction)\n        bgcolor(couleur)\n        ontimer(lambda:couleur_ciel(temps_depart, heure, screen), 1)\n</code></pre> <p>Cette fonction permet de changer la couleur du ciel le matin et lel soir. Cette fonction est r\u00e9curcive avec la methode ontimer de screen.</p> <p>Cette fonction prend en charges plusieurs arguments:  - <code>temps_depart</code> : le temps \"time.time()\" au d\u00e9but des it\u00e9rations.  - <code>heure</code> : \"jour\" ou \"nuit\" qui permet de savoir si on passe vers la nuit ou le jour.  - <code>screen</code> : la methode qui permet de faire des ontimer.</p>"},{"location":"turtle/lumieres/#1-la-fonction-_calcul_couleur_","title":"1) la fonction <code>_calcul_couleur_</code>","text":"<p>Le '_' devant le nom de la fonction permet de donner l'information a l'utilisateur que la fonction ne lui est pas destin\u00e9e.</p> <pre><code>def _calcul_couleur(couleur1:tuple, couleur2:tuple, multiplicateur:float, direction:bool) -&gt; str:\n    \"\"\"\n        calcule une proportion entre la couleur 1 et 2\n        multiplicateur est entre 0 et 1\n        direction defini si on passe de la 1 a la 2 =&gt; True sinon false\n    \"\"\"\n    couleur_return = \"\"\n    for i in range(3):\n        val = round((couleur1[i] - couleur2[i]) * (multiplicateur if direction else 1 - multiplicateur))\n        hex_val = hex(val)[2:]  # conversion en cha\u00eene hex sans le \"0x\"\n        if len(hex_val) == 1:\n            hex_val = \"0\" + hex_val\n        couleur_return += hex_val\n    return f\"#{couleur_return}\"\n</code></pre> <p>Cette fonction permet de passer d'une couleur a une autre progressivement. Elle prend en chage plusieurs arguments:  - <code>couleur1</code> : la premi\u00e8re couleur  - <code>couleur2</code> : la deuxi\u00e8me couleur  - <code>multiplicateur</code> : un flottant entre 0 et 1 qui permet de d\u00e9finir le niveau d'avancement du changement de couleur  - <code>direction</code> : un booleen True passe de la couleur 1 a la 2 et False l'inverse</p>"},{"location":"turtle/main/","title":"le fichier main.pyw","text":""},{"location":"turtle/main/#le-fichier-en-petites-etapes","title":"le fichier en petites etapes","text":"<p>Ce fichier est la base du projet, son extention .pyw permet de ne pas ouvrir de console lors de son execution.</p> <p>Ce fichier poss\u00e8de plusieures fonctions</p>"},{"location":"turtle/main/#1-la-fonction-lancement","title":"1) la fonction <code>lancement</code>","text":"<p>Cette fonction ne prend pas en charge d'argument</p> <p>cette fonction permet d'initialiser les diff\u00e9rents fichiers et turtles du projet. Elle permet egalement de lancer screen et de mettre des parametres de base.</p> <p>A la fin de celle-ci elle lance la boucle principale et attend sa fermeture</p>"},{"location":"turtle/main/#2-la-fonction-boucle","title":"2) la fonction <code>boucle</code>","text":"<p>Cette fonction est r\u00e9cursive avec la fonction ontimer de screen. Cette fonction prend en charge 3 arguments: - <code>soleil</code> : la turtle qui permet de dessiner le soleil et la lune - <code>i</code> : le nombre de boucles d\u00e9j\u00e0 effectu\u00e9es qui permet de calculer le decalage pour les nombreuses fonctions - <code>screen</code> : screen pour permettre de ne pas relancer un grand nombre d'instances de cette classe qui permet de touches a des fonctions de l'ecran</p> <p>Cette fonction est la boucle principale et elle lance les differentes fonctions de ce projet.</p>"},{"location":"turtle/main/#3-la-fonction-rue","title":"3) la fonction <code>rue</code>","text":"<p>Cette fonction permet de dessiner les immeubles. Elle prend en charge un argument: - <code>i</code> : qui est le nombre de boucles d\u00e9j\u00e0 r\u00e9alis\u00e9es</p> <p>Elle va calculer a partir de ses variables le decalage et lancer la fonction de dessin d'un immeuble 5 fois</p>"},{"location":"turtle/main/#4-la-fonction-deplacement_camera","title":"4) la fonction <code>deplacement_camera</code>","text":"<p>Cette fonction est r\u00e9cursive grace a la fonction ontimer de screen Elle prend en charge 2 arguments:   - <code>i</code> : le deplacement de base avant le decalage   - <code>temps_depart</code> : l'heure a laquelle la fonction a \u00e9t\u00e9 lanc\u00e9e pour la 1ere fois</p> <p>Cette fonction calcule le decalage a appliquer sur la camera en fonction du temps pass\u00e9.</p>"},{"location":"turtle/voitures/","title":"le fichier voitures.py","text":""},{"location":"turtle/voitures/#la-fonction-en-petites-etapes","title":"la fonction en petites etapes","text":"<p>Ce fichier ne poss\u00e8de qu'une seule fonction : la fonction <code>voiture</code> C'est pourquoi nous allons le decouper en parties de la fonction.</p> <pre><code>def voitures(heure_depart:float, t_voiture:Turtle, screen, liste_voitures:list=[[], []]) -&gt; None:\n    \"\"\" affiche les voitures \"\"\"\n    # variables\n    proba_voiture = [5, 100]\n    v_voiture = 5\n\n\n    # definition des points ecrates le plus proche possible de la camera pour eviter le lag\n    x_instant = round((time.time() - heure_depart) //8 * 1400)\n    x_min = x_instant - 20\n    x_max = x_min + 2800\n\n\n    # verifier et generer les voitures sur la ligne du dessus\n    if liste_voitures[0] != []:\n        if not x_max - liste_voitures[0][-1] &lt; 175:\n            # generer aleatoirement une voiture\n            if random.choice(range(proba_voiture[1])) &lt; proba_voiture[0]:\n                liste_voitures[0].append(x_max-5)\n    else:\n        if random.choice(range(proba_voiture[1])) &lt; proba_voiture[0]:\n            liste_voitures[0].append(x_max-5)\n    # la ligne du dessous\n    if liste_voitures[1] != []:\n        if not x_min - liste_voitures[1][-1] &lt; 175:\n            # generer aleatoirement une voiture\n            if random.choice(range(proba_voiture[1])) &lt; proba_voiture[0]:\n                liste_voitures[1].append(x_min+5)\n    else:\n        if random.choice(range(proba_voiture[0])) &lt; proba_voiture[0]:\n            liste_voitures[1].append(x_min+5)\n\n\n\n    # supprimer les voitures si il y a des voitures\n    if liste_voitures[0] != []:\n        for i in reversed(range(len(liste_voitures[0]))):\n            if not x_min &lt; liste_voitures[0][i] &lt; x_max:\n                liste_voitures[0].pop(i)\n    if liste_voitures[1] != []:\n        for i in reversed(range(len(liste_voitures[1]))):\n            if not x_min &lt; liste_voitures[1][i] &lt; x_max:\n                liste_voitures[1].pop(i)\n\n    # tout clear\n    t_voiture.clear()\n\n\n    # dessiner les voitures\n    for i in range(len(liste_voitures[0])):\n        liste_voitures[0][i] -= v_voiture\n        t_voiture.shape(\"./turtle/images/voiture.gif\")\n        t_voiture.goto(liste_voitures[0][i], 120)\n        t_voiture.stamp()\n    for i in range(len(liste_voitures[1])):\n        liste_voitures[1][i] += v_voiture\n        t_voiture.shape(\"./turtle/images/voiture.gif\")\n        t_voiture.goto(liste_voitures[1][i], 85)\n        t_voiture.stamp()\n\n\n    screen.ontimer(lambda:voitures(heure_depart, t_voiture, screen, liste_voitures), 1)\n</code></pre>"},{"location":"turtle/voitures/#1-de-la-ligne-1-a-10","title":"1) de la ligne 1 a 10","text":"<p>C'est la partie du calcul des variables. La fonction va calculer diff\u00e9rentes variables utiles.</p>"},{"location":"turtle/voitures/#2-de-la-ligne-14-a-31","title":"2) de la ligne 14 a 31","text":"<p>Cette partie sert a g\u00e9r\u00e9rer les voitures sur la route. Les voitures ne doivent pas etre trop coll\u00e9es les unes aux autres. Elle v\u00e9rifie et g\u00e9n\u00e8re les voitures pour les deux routes. La liste <code>liste_voitures</code> poss\u00e8de deux listes pour les deux sens de circulation de la route elle est initialis\u00e9e dans l'en t\u00eate vide pour \u00e9viter les erreurs.</p>"},{"location":"turtle/voitures/#3-de-la-ligne-35-a-46","title":"3) de la ligne 35 a 46","text":"<p>La fonction regarde si des voitures sont sorties de l'ecran au quel cas elle les supprimes des listes.</p> <p>Et elle clear toutes les voitures qu'elle va redessiner ensuite.</p>"},{"location":"turtle/voitures/#3-de-la-ligne-49-a-62","title":"3) de la ligne 49 a 62","text":"<p>La fonction redessine toutes les voiutres pr\u00e9sentes sur les deux routes.</p> <p>Elle se r\u00e9it\u00e8re ensuite avec la fonction ontimer de screen.</p>"}]}